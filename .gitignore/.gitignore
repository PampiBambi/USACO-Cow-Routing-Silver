import java.io.*;
import java.util.*;
public class CowRouting {
    public static void main(String[] args) throws IOException {
    	Map<long[], Integer> input = new HashMap<long[], Integer>(); 
        BufferedReader br = new BufferedReader(new FileReader("cowroute.in"));
        PrintWriter pw = new PrintWriter(new File("cowroute.out"));
        int[] line = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int start = line[0], end = line[1], n = line[2]; 
        for (int i = 0; i < n; i ++) {
        		int cost = Integer.parseInt(br.readLine().split(" ")[0]); 
        		long[] lineB = Arrays.stream(br.readLine().split(" ")).mapToLong(Long::parseLong).toArray();
        		input.put(lineB, cost); 
        }
        pw.println(answer(input, start, end)); 
        br.close();
        pw.close();
        System.exit(0);
    }
    public static String answer(Map<long[], Integer> input, int start, int end) {
    		Set<Long> verticies = new HashSet<Long>(); 
    		for (long[] i : input.keySet()) 
    			for (long j : i)
    				verticies.add(j); 
    		long[][] matrix = new long[1001][1001], numFlights = new long[1001][1001]; 
    		for (int i = 0; i < matrix.length; i ++) 
    			Arrays.fill(matrix[i], Long.MAX_VALUE);
    		long[] distanceFromStart = new long[1001], numFlightsFromStart = new long[1001]; 
    		for (long[] i : input.keySet()) {
    			int counter = 0; 
    			while (counter < i.length - 1) {
    				int numberFlights = 0;
    				for (int j = counter; j < i.length; j ++) {
    					if (matrix[(int)i[counter]][(int)i[j]] > input.get(i)) {
    						matrix[(int)i[counter]][(int)i[j]] = input.get(i); 
    						numFlights[(int)i[counter]][(int)i[j]] = numberFlights; 
    					}
    					else if (matrix[(int)i[counter]][(int)i[j]] == input.get(i))
    						numFlights[(int)i[counter]][(int)i[j]] = Math.min(numberFlights, numFlights[(int)i[counter]][(int)i[j]]); 
    					numberFlights ++; 
    				}
    				counter ++; 
    			}
    		}
    		Arrays.fill(distanceFromStart, Long.MAX_VALUE);
    		Arrays.fill(numFlightsFromStart, Long.MAX_VALUE);
    		numFlightsFromStart[start] = distanceFromStart[start] = 0; 
    		boolean[] finalized = new boolean[1001]; 
    		for (int i = 0; i < verticies.size() - 1; i ++) {
    			long minimumDistance = Long.MAX_VALUE; 
    			int minVertex = 0; 
    			for (int j = 1; j < distanceFromStart.length; j ++) 
    				if (distanceFromStart[j] < minimumDistance && !finalized[j] && verticies.contains((long)j)) {
    					minVertex = j;
    					minimumDistance = distanceFromStart[j]; 
    				}
    			finalized[minVertex] = true; 
    			for (int j = 1; j < matrix[minVertex].length; j ++) 
    				if (matrix[minVertex][j] != Long.MAX_VALUE && !finalized[j]) {
    					if (distanceFromStart[j] > matrix[minVertex][j] + distanceFromStart[minVertex]) {
    						distanceFromStart[j] = matrix[minVertex][j] + distanceFromStart[minVertex]; 
    						numFlightsFromStart[j] = numFlights[minVertex][j] + numFlightsFromStart[minVertex]; 
    					}
    					else if (distanceFromStart[j] == matrix[minVertex][j] + distanceFromStart[minVertex]) 
    						numFlightsFromStart[j] = Math.min(numFlights[minVertex][j] + numFlightsFromStart[minVertex], numFlightsFromStart[j]); 
    				}
    		}
    		if (distanceFromStart[end] == Long.MAX_VALUE)
    			distanceFromStart[end] = numFlightsFromStart[end] = -1;
    		return distanceFromStart[end] + " " + numFlightsFromStart[end]; 
    }
}
